// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ClusterAABB
#pragma kernel ClusterSampleDepth
#pragma kernel AssignLightsToClusters
#pragma kernel AppendLightBuffer

#include "./ClusterBasedLightingCommon.hlsl"

float4x4 _InverseProjectionMatrix;

RWStructuredBuffer<AABB> RWClusterAABBs;



/**
* Find the intersection of a line segment with a plane.
* This function will return true if an intersection point
* was found or false if no intersection could be found.
* Source: Real-time collision detection, Christer Ericson (2005)
*/
bool IntersectLinePlane(float3 a, float3 b, Plane p, out float3 q)
{
    float3 ab = b - a;

    float t = (p.d - dot(p.N, a)) / dot(p.N, ab);

    bool intersect = (t >= 0.0f && t <= 1.0f);

    q = float3(0, 0, 0);
    if (intersect)
    {
        q = a + t * ab;
    }

    return intersect;
}

/// Functions.hlsli
// Convert clip space coordinates to view space
float4 ClipToView(float4 clip)
{
    // View space position.
    //float4 view = mul(clip, g_Com.Camera.CameraProjectInv);
    float4 view = mul(_InverseProjectionMatrix, clip);
    // Perspecitive projection.
    view = view / view.w;

    return view;
}

// Convert screen space coordinates to view space.
float4 ScreenToView(float4 screen)
{
    // Convert to normalized texture coordinates in the range [0 .. 1].
    float2 texCoord = screen.xy * ClusterCB_ScreenDimensions.zw;

    // Convert to clip space
    float4 clip = float4(texCoord * 2.0f - 1.0f, screen.z, screen.w);

    return ClipToView(clip);
}





[numthreads(1024, 1, 1)]
void ClusterAABB(uint3 id: SV_DispatchThreadID)
{
    
    uint clusterIndex1D = id.x;

    //将1D转化为3D
    uint3 clusterIndex3D = ComputeClusterIndex3D(clusterIndex1D);

    // Compute the near and far planes for cluster K.
    Plane nearPlane = {
        0.0f, 0.0f, 1.0f, ClusterCB_ViewNear * pow(abs(ClusterCB_NearK), clusterIndex3D.z)
    };
    Plane farPlane = {
        0.0f, 0.0f, 1.0f, ClusterCB_ViewNear * pow(abs(ClusterCB_NearK), clusterIndex3D.z + 1)
    };

    // The top-left point of cluster K in screen space.
    float4 pMin = float4(clusterIndex3D.xy * ClusterCB_Size.xy, 0.0f, 1.0f);
    // The bottom-right point of cluster K in screen space.
    float4 pMax = float4((clusterIndex3D.xy + 1) * ClusterCB_Size.xy, 0.0f, 1.0f);

    // Transform the screen space points to view space.
    pMin = ScreenToView(pMin);
    pMax = ScreenToView(pMax);

    pMin.z *= -1;
    pMax.z *= -1;

    // Find the min and max points on the near and far planes.
    float3 nearMin, nearMax, farMin, farMax;
    // Origin (camera eye position)
    float3 eye = float3(0, 0, 0);
    IntersectLinePlane(eye, (float3)pMin, nearPlane, nearMin);
    IntersectLinePlane(eye, (float3)pMax, nearPlane, nearMax);
    IntersectLinePlane(eye, (float3)pMin, farPlane, farMin);
    IntersectLinePlane(eye, (float3)pMax, farPlane, farMax);

    float3 aabbMin = min(nearMin, min(nearMax, min(farMin, farMax)));
    float3 aabbMax = max(nearMin, max(nearMax, max(farMin, farMax)));

    AABB aabb = {
        aabbMin, aabbMax
    };
    
    RWClusterAABBs[clusterIndex1D] = aabb;
}


///////////////////////////////////////////


RWStructuredBuffer<uint> RWPointLightIndexCounter_Cluster;// : register(u2);
RWStructuredBuffer<uint2> RWPointLightGrid_Cluster;// : register(u4);
RWStructuredBuffer<uint> RWPointLightIndexList_Cluster;// : register(u6);

// StructuredBuffer<uint> UniqueClusters;
StructuredBuffer<AABB> ClusterAABBs;//第一步算好的全部Cluster信息
StructuredBuffer<float4> PointLights;//全部点光源信息

uint PointLightCount;//点光源总数量
float4x4 _CameraLastViewMatrix;

#define NUM_THREADS 1024
//groupshared 是一个cluster共有了 在AssignLightsToClusters 一次执行过程中共有
groupshared uint gs_ClusterIndex1D;
groupshared AABB gs_ClusterAABB;

groupshared uint gs_PointLightCount;//此Cluster的光源个数
groupshared uint gs_PointLightStartOffset;//总点光源 list 中的起始位置位置
groupshared uint gs_PointLightList[1024];//点光源总列表


float4 TransformWorldToView(float4 posWorld)
{
    float4 posView = mul(_CameraLastViewMatrix, posWorld);
    // posView.z *= -1;
    return posView;
}



[numthreads(NUM_THREADS, 1, 1)]
void AssignLightsToClusters(ComputeShaderInput IN)
{
    uint i;//当前光源下标
    uint index;//当前的Cluster已经有的光源个数
    //此核心首次调用时候 初始化groupshared变量
    if (IN.GroupIndex == 0)
    {
        gs_PointLightCount = 0;//总光源数量置为0
        //一维坐标
        gs_ClusterIndex1D = IN.GroupID.x;// UniqueClusters[IN.GroupID.x];
        gs_ClusterAABB = ClusterAABBs[gs_ClusterIndex1D];
    }

    //阻塞进程
    //等待对GroupShared变量的访问
    GroupMemoryBarrierWithGroupSync();

    //计算当前 cluster  所受点光源影响的总个数 并填充光源index 列表
    for (i = IN.GroupIndex; i < PointLightCount; i += NUM_THREADS)
    {
        float4 pointLight = PointLights[i];
        float3 pointLightPositionVS = TransformWorldToView(float4(pointLight.xyz, 1)).xyz;
        //灯光是世界坐标的 需要放在同一坐标系下
        //AABB都是基于0矩阵的 非世界坐标
        //
        Sphere sphere = {
            pointLightPositionVS, pointLight.w
        };


        if (SphereInsideAABB(sphere, gs_ClusterAABB))
        // if (true)//先必定相交

        {
            //向目标cluster添加pointlight 下标
            //gs_PointLightCount ++
            //每个cluster存放的pointLightIndex 填充pointlist 的列表
            // AppendLight(i, gs_PointLightCount, gs_PointLightList);
            InterlockedAdd(gs_PointLightCount, 1, index);
            if (index < 1024)
            {
                gs_PointLightList[index] = i;
            }
        }
    }

    //阻塞进程
    GroupMemoryBarrierWithGroupSync();

    //使用gs_PointLightStartOffset，gs_PointLightCount，填充light grid
    // Now update the global light grids with the light lists and light counts.
    if (IN.GroupIndex == 0)
    {
        // Update light grid for point lights.
        //gs_PointLightCount 是本次计算的点光源数量
        InterlockedAdd(RWPointLightIndexCounter_Cluster[0], gs_PointLightCount, gs_PointLightStartOffset);
        // 存放的是起始坐标 以及总数量 这样就可以方便计算了
        RWPointLightGrid_Cluster[gs_ClusterIndex1D] = uint2(gs_PointLightStartOffset, gs_PointLightCount);
    }


    GroupMemoryBarrierWithGroupSync();

    //填充light 列表
    // Now update the global light index lists with the group shared light lists.
    for (i = IN.GroupIndex; i < gs_PointLightCount; i += NUM_THREADS)
    {
        RWPointLightIndexList_Cluster[gs_PointLightStartOffset +i] = gs_PointLightList[i];
    }
}

AppendStructuredBuffer<float4> AppendPointLights;

//Debug
[numthreads(1024, 1, 1)]
void AppendLightBuffer(ComputeShaderInput IN)
{
    float4 pointPosRange = PointLights[IN.GroupID.x];
    AppendPointLights.Append(pointPosRange);
}